class MergeAndFilterVariantCalls(ChainlinkTransformer):
	# operates on the outputs of AssessVariantCalls
	def __init__(self, context=None, name="Merge and Filter Variant Calls", basename='', dir=None,
				 include_subthreshold=False, use_top_known=False, call_reference=False, model_singletons=False):
		ChainlinkTransformer.__init__(self, context=context)
		self.name = name
		self.basename = basename
		self.dir = dir
		self.include_subthreshold = include_subthreshold
		self.use_top_known = use_top_known
		self.call_reference = call_reference
		self.model_singletons = model_singletons
	
	def transform(self, assess_outs):
		
		import chainlink
		
		t = self.createTask()
		attr_assess_json_list = [a['assess_json'] for a in assess_outs]
		attr_assess_vcf_list = [a['assess_vcf'] for a in assess_outs]
		attr_assess_txt_list = [a['assess_txt'] for a in assess_outs]
		assessJSONs = registerParameterList(t, attr_assess_json_list, "ASSESS_JSONS")
		assessVCFs = registerParameterList(t, attr_assess_vcf_list, "ASSESS_VCFS")
		
		options = ''
		if self.include_subthreshold:
			options += ' --include_subthreshold' 
		if self.call_reference:
			options += ' --call_reference'
		if self.model_singletons:
			t.registerInput("NOISE_MODEL_REFERENCE", self.context.attr_noise_model)
			options += ' --model_singletons'
			options += ' --noise_model_singleton #{NOISE_MODEL_REFERENCE}'
		if self.use_top_known:
			t.registerInput("TOP_KNOWN_REFERENCE", self.context.attr_top_known)
			options += ' --top_known #{TOP_KNOWN_REFERENCE}'
		
		t.commandTemplate = '; '.join([
			'set -eo pipefail',
			"awk 'ARGIND==1{print$0;next}!/^#/' %s > %s.filteredcalls.vcf" % (' '.join(assessVCFs), self.basename),
			'cat %s | filter_variants.py --filtered_json %s.filteredcalls.json --filtered_text %s.filteredcalls.txt --all_text %s.allcalls.txt --all_json %s.allcalls.json %s' % (' '.join(assessJSONs), self.basename ,self.basename,self.basename,self.basename, options),
		])
	
		return {
			'vcf_filtered': t.addFileOutput(
				"filtered variant calls in VCF format",
				'%s.filteredcalls.vcf' % self.basename,
				self.target(self.dir) if self.dir else chainlink.DeletionPolicy.DependencySatisfaction
			),
			'json_all': t.addFileOutput(
				"all variant calls in JSON format",
				'%s.allcalls.json' % self.basename,
				self.target(self.dir) if self.dir else chainlink.DeletionPolicy.DependencySatisfaction
			),
			'json_filtered': t.addFileOutput(
				"filtered variant calls in JSON format",
				'%s.filteredcalls.json' % self.basename,
				self.target(self.dir) if self.dir else chainlink.DeletionPolicy.DependencySatisfaction
			),
			'text_all': t.addFileOutput(
				"all variant calls in text format",
				'%s.allcalls.txt' % self.basename,
				self.target(self.dir) if self.dir else chainlink.DeletionPolicy.DependencySatisfaction
			),
			'text_filtered': t.addFileOutput(
				"filtered variant calls in text format",
				'%s.filteredcalls.txt' % self.basename,
				self.target(self.dir) if self.dir else chainlink.DeletionPolicy.DependencySatisfaction
			),
		}
